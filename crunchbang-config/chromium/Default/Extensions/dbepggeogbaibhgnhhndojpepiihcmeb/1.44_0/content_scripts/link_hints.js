// Generated by CoffeeScript 1.3.3
(function() {
  var COPY_LINK_URL, LinkHints, OPEN_INCOGNITO, OPEN_IN_CURRENT_TAB, OPEN_IN_NEW_TAB, OPEN_WITH_QUEUE, alphabetHints, filterHints, numberToHintString, root, spanWrap;

  OPEN_IN_CURRENT_TAB = {};

  OPEN_IN_NEW_TAB = {};

  OPEN_WITH_QUEUE = {};

  COPY_LINK_URL = {};

  OPEN_INCOGNITO = {};

  LinkHints = {
    hintMarkerContainingDiv: null,
    mode: void 0,
    linkActivator: void 0,
    delayMode: false,
    markerMatcher: void 0,
    isActive: false,
    init: function() {
      return this.markerMatcher = settings.get("filterLinkHints") ? filterHints : alphabetHints;
    },
    clickableElementsXPath: DomUtils.makeXPath(["a", "area[@href]", "textarea", "button", "select", "input[not(@type='hidden' or @disabled or @readonly)]", "*[@onclick or @tabindex or @role='link' or @role='button' or contains(@class, 'button') or " + "@contenteditable='' or translate(@contenteditable, 'TRUE', 'true')='true']"]),
    activateModeToOpenInNewTab: function() {
      return this.activateMode(OPEN_IN_NEW_TAB);
    },
    activateModeToCopyLinkUrl: function() {
      return this.activateMode(COPY_LINK_URL);
    },
    activateModeWithQueue: function() {
      return this.activateMode(OPEN_WITH_QUEUE);
    },
    activateModeToOpenIncognito: function() {
      return this.activateMode(OPEN_INCOGNITO);
    },
    activateMode: function(mode) {
      var el, hintMarkers;
      if (mode == null) {
        mode = OPEN_IN_CURRENT_TAB;
      }
      if (!document.documentElement) {
        return;
      }
      if (this.isActive) {
        return;
      }
      this.isActive = true;
      this.setOpenLinkMode(mode);
      hintMarkers = this.markerMatcher.fillInMarkers((function() {
        var _i, _len, _ref, _results;
        _ref = this.getVisibleClickableElements();
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          el = _ref[_i];
          _results.push(this.createMarkerFor(el));
        }
        return _results;
      }).call(this));
      this.hintMarkerContainingDiv = DomUtils.addElementList(hintMarkers, {
        id: "vimiumHintMarkerContainer",
        className: "vimiumReset"
      });
      return this.handlerId = handlerStack.push({
        keydown: this.onKeyDownInMode.bind(this, hintMarkers),
        keypress: function() {
          return false;
        },
        keyup: function() {
          return false;
        }
      });
    },
    setOpenLinkMode: function(mode) {
      this.mode = mode;
      if (this.mode === OPEN_IN_NEW_TAB || this.mode === OPEN_WITH_QUEUE) {
        if (this.mode === OPEN_IN_NEW_TAB) {
          HUD.show("Open link in new tab");
        } else {
          HUD.show("Open multiple links in a new tab");
        }
        return this.linkActivator = function(link) {
          return DomUtils.simulateClick(link, {
            metaKey: KeyboardUtils.platform === "Mac",
            ctrlKey: KeyboardUtils.platform !== "Mac"
          });
        };
      } else if (this.mode === COPY_LINK_URL) {
        HUD.show("Copy link URL to Clipboard");
        return this.linkActivator = function(link) {
          return chrome.runtime.sendMessage({
            handler: "copyToClipboard",
            data: link.href
          });
        };
      } else if (this.mode === OPEN_INCOGNITO) {
        HUD.show("Open link in incognito window");
        return this.linkActivator = function(link) {
          return chrome.runtime.sendMessage({
            handler: 'openUrlInIncognito',
            url: link.href
          });
        };
      } else {
        HUD.show("Open link in current tab");
        return this.linkActivator = function(link) {
          return setTimeout(DomUtils.simulateClick.bind(DomUtils, link), 400);
        };
      }
    },
    createMarkerFor: function(link) {
      var clientRect, marker;
      marker = document.createElement("div");
      marker.className = "vimiumReset internalVimiumHintMarker vimiumHintMarker";
      marker.clickableItem = link.element;
      clientRect = link.rect;
      marker.style.left = clientRect.left + window.scrollX + "px";
      marker.style.top = clientRect.top + window.scrollY + "px";
      marker.rect = link.rect;
      return marker;
    },
    getVisibleClickableElements: function() {
      var c, clientRect, coords, element, i, img, imgClientRects, map, rect, resultSet, visibleElements, _i, _ref;
      resultSet = DomUtils.evaluateXPath(this.clickableElementsXPath, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE);
      visibleElements = [];
      for (i = _i = 0, _ref = resultSet.snapshotLength; _i < _ref; i = _i += 1) {
        element = resultSet.snapshotItem(i);
        clientRect = DomUtils.getVisibleClientRect(element, clientRect);
        if (clientRect !== null) {
          visibleElements.push({
            element: element,
            rect: clientRect
          });
        }
        if (element.localName === "area") {
          map = element.parentElement;
          if (!map) {
            continue;
          }
          img = document.querySelector("img[usemap='#" + map.getAttribute("name") + "']");
          if (!img) {
            continue;
          }
          imgClientRects = img.getClientRects();
          if (imgClientRects.length === 0) {
            continue;
          }
          c = element.coords.split(/,/);
          coords = [parseInt(c[0], 10), parseInt(c[1], 10), parseInt(c[2], 10), parseInt(c[3], 10)];
          rect = {
            top: imgClientRects[0].top + coords[1],
            left: imgClientRects[0].left + coords[0],
            right: imgClientRects[0].left + coords[2],
            bottom: imgClientRects[0].top + coords[3],
            width: coords[2] - coords[0],
            height: coords[3] - coords[1]
          };
          visibleElements.push({
            element: element,
            rect: rect
          });
        }
      }
      return visibleElements;
    },
    onKeyDownInMode: function(hintMarkers, event) {
      var delay, keyResult, linksMatched, marker, matched, prev_mode, _i, _j, _len, _len1, _ref,
        _this = this;
      if (this.delayMode) {
        return;
      }
      if (event.keyCode === keyCodes.shiftKey && this.mode !== COPY_LINK_URL) {
        prev_mode = this.mode;
        this.setOpenLinkMode(this.mode === OPEN_IN_CURRENT_TAB ? OPEN_IN_NEW_TAB : OPEN_IN_CURRENT_TAB);
        handlerStack.push({
          keyup: function(event) {
            if (event.keyCode !== keyCodes.shiftKey) {
              return;
            }
            if (_this.isActive) {
              _this.setOpenLinkMode(prev_mode);
            }
            return _this.remove();
          }
        });
      }
      if (KeyboardUtils.isEscape(event)) {
        this.deactivateMode();
      } else if (event.keyCode !== keyCodes.shiftKey) {
        keyResult = this.markerMatcher.matchHintsByKey(hintMarkers, event);
        linksMatched = keyResult.linksMatched;
        delay = (_ref = keyResult.delay) != null ? _ref : 0;
        if (linksMatched.length === 0) {
          this.deactivateMode();
        } else if (linksMatched.length === 1) {
          this.activateLink(linksMatched[0], delay);
        } else {
          for (_i = 0, _len = hintMarkers.length; _i < _len; _i++) {
            marker = hintMarkers[_i];
            this.hideMarker(marker);
          }
          for (_j = 0, _len1 = linksMatched.length; _j < _len1; _j++) {
            matched = linksMatched[_j];
            this.showMarker(matched, this.markerMatcher.hintKeystrokeQueue.length);
          }
        }
      }
      return false;
    },
    activateLink: function(matchedLink, delay) {
      var clickEl;
      this.delayMode = true;
      clickEl = matchedLink.clickableItem;
      if (DomUtils.isSelectable(clickEl)) {
        DomUtils.simulateSelect(clickEl);
        return this.deactivateMode(delay, function() {
          return LinkHints.delayMode = false;
        });
      } else {
        if (clickEl.nodeName.toLowerCase() === "input" && clickEl.type !== "button") {
          clickEl.focus();
        }
        DomUtils.flashRect(matchedLink.rect);
        this.linkActivator(clickEl);
        if (this.mode === OPEN_WITH_QUEUE) {
          return this.deactivateMode(delay, function() {
            LinkHints.delayMode = false;
            return LinkHints.activateModeWithQueue();
          });
        } else {
          return this.deactivateMode(delay, function() {
            return LinkHints.delayMode = false;
          });
        }
      }
    },
    showMarker: function(linkMarker, matchingCharCount) {
      var j, _i, _ref, _results;
      linkMarker.style.display = "";
      _results = [];
      for (j = _i = 0, _ref = linkMarker.childNodes.length; 0 <= _ref ? _i < _ref : _i > _ref; j = 0 <= _ref ? ++_i : --_i) {
        if (j < matchingCharCount) {
          _results.push(linkMarker.childNodes[j].classList.add("matchingCharacter"));
        } else {
          _results.push(linkMarker.childNodes[j].classList.remove("matchingCharacter"));
        }
      }
      return _results;
    },
    hideMarker: function(linkMarker) {
      return linkMarker.style.display = "none";
    },
    deactivateMode: function(delay, callback) {
      var deactivate,
        _this = this;
      deactivate = function() {
        if (LinkHints.markerMatcher.deactivate) {
          LinkHints.markerMatcher.deactivate();
        }
        if (LinkHints.hintMarkerContainingDiv) {
          DomUtils.removeElement(LinkHints.hintMarkerContainingDiv);
        }
        LinkHints.hintMarkerContainingDiv = null;
        handlerStack.remove(_this.handlerId);
        HUD.hide();
        return _this.isActive = false;
      };
      if (!delay) {
        deactivate();
        if (callback) {
          return callback();
        }
      } else {
        return setTimeout(function() {
          deactivate();
          if (callback) {
            return callback();
          }
        }, delay);
      }
    }
  };

  alphabetHints = {
    hintKeystrokeQueue: [],
    logXOfBase: function(x, base) {
      return Math.log(x) / Math.log(base);
    },
    fillInMarkers: function(hintMarkers) {
      var hintStrings, idx, marker, _i, _len;
      hintStrings = this.hintStrings(hintMarkers.length);
      for (idx = _i = 0, _len = hintMarkers.length; _i < _len; idx = ++_i) {
        marker = hintMarkers[idx];
        marker.hintString = hintStrings[idx];
        marker.innerHTML = spanWrap(marker.hintString.toUpperCase());
      }
      return hintMarkers;
    },
    hintStrings: function(linkCount) {
      var digitsNeeded, hintStrings, i, linkHintCharacters, longHintCount, shortHintCount, start, _i, _j, _ref;
      linkHintCharacters = settings.get("linkHintCharacters");
      digitsNeeded = Math.ceil(this.logXOfBase(linkCount, linkHintCharacters.length));
      shortHintCount = Math.floor((Math.pow(linkHintCharacters.length, digitsNeeded) - linkCount) / linkHintCharacters.length);
      longHintCount = linkCount - shortHintCount;
      hintStrings = [];
      if (digitsNeeded > 1) {
        for (i = _i = 0; 0 <= shortHintCount ? _i < shortHintCount : _i > shortHintCount; i = 0 <= shortHintCount ? ++_i : --_i) {
          hintStrings.push(numberToHintString(i, linkHintCharacters, digitsNeeded - 1));
        }
      }
      start = shortHintCount * linkHintCharacters.length;
      for (i = _j = start, _ref = start + longHintCount; start <= _ref ? _j < _ref : _j > _ref; i = start <= _ref ? ++_j : --_j) {
        hintStrings.push(numberToHintString(i, linkHintCharacters, digitsNeeded));
      }
      return this.shuffleHints(hintStrings, linkHintCharacters.length);
    },
    shuffleHints: function(hints, characterSetLength) {
      var bucket, buckets, hint, i, result, _i, _j, _len, _len1;
      buckets = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; _i < characterSetLength; i = _i += 1) {
          _results.push([]);
        }
        return _results;
      })();
      for (i = _i = 0, _len = hints.length; _i < _len; i = ++_i) {
        hint = hints[i];
        buckets[i % buckets.length].push(hint);
      }
      result = [];
      for (_j = 0, _len1 = buckets.length; _j < _len1; _j++) {
        bucket = buckets[_j];
        result = result.concat(bucket);
      }
      return result;
    },
    matchHintsByKey: function(hintMarkers, event) {
      var keyChar, linksMatched, matchString;
      keyChar = KeyboardUtils.getKeyChar(event).toLowerCase();
      if (event.keyCode === keyCodes.backspace || event.keyCode === keyCodes.deleteKey) {
        if (!this.hintKeystrokeQueue.pop()) {
          return {
            linksMatched: []
          };
        }
      } else if (keyChar) {
        this.hintKeystrokeQueue.push(keyChar);
      }
      matchString = this.hintKeystrokeQueue.join("");
      linksMatched = hintMarkers.filter(function(linkMarker) {
        return linkMarker.hintString.indexOf(matchString) === 0;
      });
      return {
        linksMatched: linksMatched
      };
    },
    deactivate: function() {
      return this.hintKeystrokeQueue = [];
    }
  };

  filterHints = {
    hintKeystrokeQueue: [],
    linkTextKeystrokeQueue: [],
    labelMap: {},
    generateLabelMap: function() {
      var forElement, label, labelText, labels, _i, _len, _results;
      labels = document.querySelectorAll("label");
      _results = [];
      for (_i = 0, _len = labels.length; _i < _len; _i++) {
        label = labels[_i];
        forElement = label.getAttribute("for");
        if (forElement) {
          labelText = label.textContent.trim();
          if (labelText[labelText.length - 1] === ":") {
            labelText = labelText.substr(0, labelText.length - 1);
          }
          _results.push(this.labelMap[forElement] = labelText);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    },
    generateHintString: function(linkHintNumber) {
      return (numberToHintString(linkHintNumber + 1, settings.get("linkHintNumbers"))).toUpperCase();
    },
    generateLinkText: function(element) {
      var linkText, nodeName, showLinkText;
      linkText = "";
      showLinkText = false;
      nodeName = element.nodeName.toLowerCase();
      if (nodeName === "input") {
        if (this.labelMap[element.id]) {
          linkText = this.labelMap[element.id];
          showLinkText = true;
        } else if (element.type !== "password") {
          linkText = element.value;
          if (!linkText && 'placeholder' in element) {
            linkText = element.placeholder;
          }
        }
      } else if (nodeName === "a" && !element.textContent.trim() && element.firstElementChild && element.firstElementChild.nodeName.toLowerCase() === "img") {
        linkText = element.firstElementChild.alt || element.firstElementChild.title;
        if (linkText) {
          showLinkText = true;
        }
      } else {
        linkText = element.textContent || element.innerHTML;
      }
      return {
        text: linkText,
        show: showLinkText
      };
    },
    renderMarker: function(marker) {
      return marker.innerHTML = spanWrap(marker.hintString + (marker.showLinkText ? ": " + marker.linkText : ""));
    },
    fillInMarkers: function(hintMarkers) {
      var idx, linkTextObject, marker, _i, _len;
      this.generateLabelMap();
      for (idx = _i = 0, _len = hintMarkers.length; _i < _len; idx = ++_i) {
        marker = hintMarkers[idx];
        marker.hintString = this.generateHintString(idx);
        linkTextObject = this.generateLinkText(marker.clickableItem);
        marker.linkText = linkTextObject.text;
        marker.showLinkText = linkTextObject.show;
        this.renderMarker(marker);
      }
      return hintMarkers;
    },
    matchHintsByKey: function(hintMarkers, event) {
      var delay, keyChar, linksMatched, marker, matchString, userIsTypingLinkText, _i, _len;
      keyChar = KeyboardUtils.getKeyChar(event);
      delay = 0;
      userIsTypingLinkText = false;
      if (event.keyCode === keyCodes.enter) {
        for (_i = 0, _len = hintMarkers.length; _i < _len; _i++) {
          marker = hintMarkers[_i];
          if (marker.style.display !== "none") {
            return {
              linksMatched: [marker]
            };
          }
        }
      } else if (event.keyCode === keyCodes.backspace || event.keyCode === keyCodes.deleteKey) {
        if (!this.hintKeystrokeQueue.pop() && !this.linkTextKeystrokeQueue.pop()) {
          return {
            linksMatched: []
          };
        }
      } else if (keyChar) {
        if (settings.get("linkHintNumbers").indexOf(keyChar) >= 0) {
          this.hintKeystrokeQueue.push(keyChar);
        } else {
          this.hintKeystrokeQueue = [];
          this.linkTextKeystrokeQueue.push(keyChar);
          userIsTypingLinkText = true;
        }
      }
      linksMatched = this.filterLinkHints(hintMarkers);
      matchString = this.hintKeystrokeQueue.join("");
      linksMatched = linksMatched.filter(function(linkMarker) {
        return !linkMarker.filtered && linkMarker.hintString.indexOf(matchString) === 0;
      });
      if (linksMatched.length === 1 && userIsTypingLinkText) {
        delay = 200;
      }
      return {
        linksMatched: linksMatched,
        delay: delay
      };
    },
    filterLinkHints: function(hintMarkers) {
      var linkMarker, linkSearchString, linksMatched, matchedLink, oldHintString, _i, _len;
      linksMatched = [];
      linkSearchString = this.linkTextKeystrokeQueue.join("");
      for (_i = 0, _len = hintMarkers.length; _i < _len; _i++) {
        linkMarker = hintMarkers[_i];
        matchedLink = linkMarker.linkText.toLowerCase().indexOf(linkSearchString.toLowerCase()) >= 0;
        if (!matchedLink) {
          linkMarker.filtered = true;
        } else {
          linkMarker.filtered = false;
          oldHintString = linkMarker.hintString;
          linkMarker.hintString = this.generateHintString(linksMatched.length);
          if (linkMarker.hintString !== oldHintString) {
            this.renderMarker(linkMarker);
          }
          linksMatched.push(linkMarker);
        }
      }
      return linksMatched;
    },
    deactivate: function(delay, callback) {
      this.hintKeystrokeQueue = [];
      this.linkTextKeystrokeQueue = [];
      return this.labelMap = {};
    }
  };

  spanWrap = function(hintString) {
    var char, innerHTML, _i, _len;
    innerHTML = [];
    for (_i = 0, _len = hintString.length; _i < _len; _i++) {
      char = hintString[_i];
      innerHTML.push("<span class='vimiumReset'>" + char + "</span>");
    }
    return innerHTML.join("");
  };

  numberToHintString = function(number, characterSet, numHintDigits) {
    var base, hintString, hintStringLength, i, remainder, _i, _ref;
    if (numHintDigits == null) {
      numHintDigits = 0;
    }
    base = characterSet.length;
    hintString = [];
    remainder = 0;
    while (true) {
      remainder = number % base;
      hintString.unshift(characterSet[remainder]);
      number -= remainder;
      number /= Math.floor(base);
      if (!(number > 0)) {
        break;
      }
    }
    hintStringLength = hintString.length;
    for (i = _i = 0, _ref = numHintDigits - hintStringLength; _i < _ref; i = _i += 1) {
      hintString.unshift(characterSet[0]);
    }
    return hintString.join("");
  };

  root = typeof exports !== "undefined" && exports !== null ? exports : window;

  root.LinkHints = LinkHints;

}).call(this);
